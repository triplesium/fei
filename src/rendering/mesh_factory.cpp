/// This file of code is generated by AI.

#include "rendering/mesh_factory.hpp"

#include <cmath>
#include <vector>

namespace fei {

namespace {

void push_vertex(
    std::vector<std::array<float, 3>>& positions,
    std::vector<std::array<float, 3>>& normals,
    std::vector<std::array<float, 2>>& uvs,
    float px,
    float py,
    float pz,
    float nx,
    float ny,
    float nz,
    float u,
    float v
) {
    positions.push_back({px, py, pz});
    normals.push_back({nx, ny, nz});
    uvs.push_back({u, v});
}

void build_ring(
    float radius,
    float height,
    float y,
    float v_coord,
    std::uint32_t segments,
    bool top_cap,
    std::vector<std::array<float, 3>>& positions,
    std::vector<std::array<float, 3>>& normals,
    std::vector<std::array<float, 2>>& uvs,
    std::vector<std::uint32_t>& indices,
    std::uint32_t& index_offset
) {
    float angle_step = 2.0f * PI / segments;

    // Center vertex for cap
    push_vertex(
        positions,
        normals,
        uvs,
        0.0f,
        y,
        0.0f,
        0.0f,
        top_cap ? 1.0f : -1.0f,
        0.0f,
        0.5f,
        0.5f
    );
    std::uint32_t center_index = index_offset++;

    for (std::uint32_t i = 0; i <= segments; ++i) {
        float angle = i * angle_step;
        float x = radius * std::cos(angle);
        float z = radius * std::sin(angle);
        float u = (x / radius + 1.0f) * 0.5f;
        float v = (z / radius + 1.0f) * 0.5f;

        push_vertex(
            positions,
            normals,
            uvs,
            x,
            y,
            z,
            0.0f,
            top_cap ? 1.0f : -1.0f,
            0.0f,
            u,
            v
        );
        index_offset++;

        if (i < segments) {
            if (top_cap) {
                indices.push_back(center_index);
                indices.push_back(center_index + i + 2);
                indices.push_back(center_index + i + 1);
            } else {
                indices.push_back(center_index);
                indices.push_back(center_index + i + 1);
                indices.push_back(center_index + i + 2);
            }
        }
    }
}

} // namespace

std::unique_ptr<Mesh> MeshFactory::create_cube(float size) {
    auto mesh = std::make_unique<Mesh>(RenderPrimitive::Triangles);

    float h = size * 0.5f;

    std::vector<std::array<float, 3>> positions = {
        // Front
        {-h, -h, h},
        {h, -h, h},
        {h, h, h},
        {-h, h, h},
        // Back
        {h, -h, -h},
        {-h, -h, -h},
        {-h, h, -h},
        {h, h, -h},
        // Left
        {-h, -h, -h},
        {-h, -h, h},
        {-h, h, h},
        {-h, h, -h},
        // Right
        {h, -h, h},
        {h, -h, -h},
        {h, h, -h},
        {h, h, h},
        // Top
        {-h, h, h},
        {h, h, h},
        {h, h, -h},
        {-h, h, -h},
        // Bottom
        {-h, -h, -h},
        {h, -h, -h},
        {h, -h, h},
        {-h, -h, h},
    };

    std::vector<std::array<float, 3>> normals = {
        // Front
        {0, 0, 1},
        {0, 0, 1},
        {0, 0, 1},
        {0, 0, 1},
        // Back
        {0, 0, -1},
        {0, 0, -1},
        {0, 0, -1},
        {0, 0, -1},
        // Left
        {-1, 0, 0},
        {-1, 0, 0},
        {-1, 0, 0},
        {-1, 0, 0},
        // Right
        {1, 0, 0},
        {1, 0, 0},
        {1, 0, 0},
        {1, 0, 0},
        // Top
        {0, 1, 0},
        {0, 1, 0},
        {0, 1, 0},
        {0, 1, 0},
        // Bottom
        {0, -1, 0},
        {0, -1, 0},
        {0, -1, 0},
        {0, -1, 0},
    };

    std::vector<std::array<float, 2>> uvs = {
        // Front
        {0, 0},
        {1, 0},
        {1, 1},
        {0, 1},
        // Back
        {0, 0},
        {1, 0},
        {1, 1},
        {0, 1},
        // Left
        {0, 0},
        {1, 0},
        {1, 1},
        {0, 1},
        // Right
        {0, 0},
        {1, 0},
        {1, 1},
        {0, 1},
        // Top
        {0, 0},
        {1, 0},
        {1, 1},
        {0, 1},
        // Bottom
        {0, 0},
        {1, 0},
        {1, 1},
        {0, 1},
    };

    std::vector<std::uint32_t> indices;
    for (int i = 0; i < 6; ++i) {
        std::uint32_t base = i * 4;
        indices.push_back(base + 0);
        indices.push_back(base + 1);
        indices.push_back(base + 2);
        indices.push_back(base + 2);
        indices.push_back(base + 3);
        indices.push_back(base + 0);
    }

    mesh->insert_attribute(Mesh::ATTRIBUTE_POSITION, positions);
    mesh->insert_attribute(Mesh::ATTRIBUTE_NORMAL, normals);
    mesh->insert_attribute(Mesh::ATTRIBUTE_UV_0, uvs);
    mesh->insert_indices(indices);

    return mesh;
}

std::unique_ptr<Mesh> MeshFactory::create_sphere(
    float radius,
    std::uint32_t segments,
    std::uint32_t rings
) {
    auto mesh = std::make_unique<Mesh>(RenderPrimitive::Triangles);

    std::vector<std::array<float, 3>> positions;
    std::vector<std::array<float, 3>> normals;
    std::vector<std::array<float, 2>> uvs;
    std::vector<std::uint32_t> indices;

    for (std::uint32_t i = 0; i <= rings; ++i) {
        float v = static_cast<float>(i) / rings;
        float phi = v * PI;

        for (std::uint32_t j = 0; j <= segments; ++j) {
            float u = static_cast<float>(j) / segments;
            float theta = u * 2.0f * PI;
            float x = -radius * std::sin(phi) * std::cos(theta);
            float y = radius * std::cos(phi);
            float z = radius * std::sin(phi) * std::sin(theta);

            push_vertex(
                positions,
                normals,
                uvs,
                x,
                y,
                z,
                x / radius,
                y / radius,
                z / radius,
                u,
                v
            );
        }
    }

    for (std::uint32_t i = 0; i < rings; ++i) {
        for (std::uint32_t j = 0; j < segments; ++j) {
            std::uint32_t a = i * (segments + 1) + j;
            std::uint32_t b = a + segments + 1;

            indices.push_back(a);
            indices.push_back(b);
            indices.push_back(a + 1);

            indices.push_back(a + 1);
            indices.push_back(b);
            indices.push_back(b + 1);
        }
    }

    mesh->insert_attribute(Mesh::ATTRIBUTE_POSITION, positions);
    mesh->insert_attribute(Mesh::ATTRIBUTE_NORMAL, normals);
    mesh->insert_attribute(Mesh::ATTRIBUTE_UV_0, uvs);
    mesh->insert_indices(indices);

    return mesh;
}

std::unique_ptr<Mesh> MeshFactory::create_capsule(
    float radius,
    float length,
    std::uint32_t segments,
    std::uint32_t rings
) {
    auto mesh = std::make_unique<Mesh>(RenderPrimitive::Triangles);
    std::vector<std::array<float, 3>> positions;
    std::vector<std::array<float, 3>> normals;
    std::vector<std::array<float, 2>> uvs;
    std::vector<std::uint32_t> indices;

    float half_length = length * 0.5f;
    std::uint32_t stride = segments + 1;

    // Helper to generate ring
    auto generate_ring =
        [&](float y_offset, float phi, float v_offset, float v_scale) {
            float y = radius * std::cos(phi);
            float r = radius * std::sin(phi);

            for (std::uint32_t j = 0; j <= segments; ++j) {
                float u = static_cast<float>(j) / segments;
                float theta = u * 2.0f * PI;

                float x = -r * std::cos(theta);
                float z = r * std::sin(theta);

                float nx = x / radius;
                float ny = y / radius;
                float nz = z / radius;

                push_vertex(
                    positions,
                    normals,
                    uvs,
                    x,
                    y + y_offset,
                    z,
                    nx,
                    ny,
                    nz,
                    u,
                    (v_offset + (static_cast<float>(phi) / PI)) * v_scale
                );
            }
        };

    // Top Hemisphere
    for (std::uint32_t i = 0; i <= rings; ++i) {
        float phi = static_cast<float>(i) / rings * (PI * 0.5f);
        generate_ring(half_length, phi, 0.0f, 1.0f);
    }

    // Bottom Hemisphere
    for (std::uint32_t i = 0; i <= rings; ++i) {
        float phi = (PI * 0.5f) + static_cast<float>(i) / rings * (PI * 0.5f);
        generate_ring(-half_length, phi, 0.0f, 1.0f);
    }

    // Indices
    // Re-verify: we pushed rings+1 for top, then rings+1 for bottom.
    // Total rows = (rings + 1) + (rings + 1) = 2*rings + 2.
    // But index connection loop should cover all rows - 1.

    for (std::uint32_t i = 0; i < (rings + 1) * 2 - 1; ++i) {
        for (std::uint32_t j = 0; j < segments; ++j) {
            std::uint32_t a = i * stride + j;
            std::uint32_t b = a + stride;

            indices.push_back(a);
            indices.push_back(b);
            indices.push_back(a + 1);

            indices.push_back(a + 1);
            indices.push_back(b);
            indices.push_back(b + 1);
        }
    }

    mesh->insert_attribute(Mesh::ATTRIBUTE_POSITION, positions);
    mesh->insert_attribute(Mesh::ATTRIBUTE_NORMAL, normals);
    mesh->insert_attribute(Mesh::ATTRIBUTE_UV_0, uvs);
    mesh->insert_indices(indices);

    return mesh;
}

std::unique_ptr<Mesh> MeshFactory::create_cylinder(
    float radius,
    float height,
    std::uint32_t segments
) {
    auto mesh = std::make_unique<Mesh>(RenderPrimitive::Triangles);
    std::vector<std::array<float, 3>> positions;
    std::vector<std::array<float, 3>> normals;
    std::vector<std::array<float, 2>> uvs;
    std::vector<std::uint32_t> indices;

    std::uint32_t index_offset = 0;
    float half_height = height * 0.5f;

    // Top Cap
    build_ring(
        radius,
        height,
        half_height,
        0.0f,
        segments,
        true,
        positions,
        normals,
        uvs,
        indices,
        index_offset
    );

    // Body
    float angle_step = 2.0f * PI / segments;
    std::uint32_t body_start_idx = index_offset;

    // Top Ring Body
    for (std::uint32_t i = 0; i <= segments; ++i) {
        float angle = i * angle_step;
        float x = radius * std::cos(angle);
        float z = radius * std::sin(angle);
        float u = static_cast<float>(i) / segments;

        push_vertex(
            positions,
            normals,
            uvs,
            x,
            half_height,
            z,
            std::cos(angle),
            0.0f,
            std::sin(angle),
            u,
            0.0f
        );
    }
    std::uint32_t top_ring_start = body_start_idx;
    body_start_idx += (segments + 1);

    // Bottom Ring Body
    for (std::uint32_t i = 0; i <= segments; ++i) {
        float angle = i * angle_step;
        float x = radius * std::cos(angle);
        float z = radius * std::sin(angle);
        float u = static_cast<float>(i) / segments;

        push_vertex(
            positions,
            normals,
            uvs,
            x,
            -half_height,
            z,
            std::cos(angle),
            0.0f,
            std::sin(angle),
            u,
            1.0f
        );
    }
    index_offset += (segments + 1) * 2;

    // Body Indices
    for (std::uint32_t i = 0; i < segments; ++i) {
        std::uint32_t top_curr = top_ring_start + i;
        std::uint32_t top_next = top_ring_start + i + 1;
        std::uint32_t bot_curr = top_curr + (segments + 1);
        std::uint32_t bot_next = top_next + (segments + 1);

        indices.push_back(top_curr);
        indices.push_back(bot_curr);
        indices.push_back(top_next);

        indices.push_back(top_next);
        indices.push_back(bot_curr);
        indices.push_back(bot_next);
    }

    // Bottom Cap
    build_ring(
        radius,
        height,
        -half_height,
        1.0f,
        segments,
        false,
        positions,
        normals,
        uvs,
        indices,
        index_offset
    );

    mesh->insert_attribute(Mesh::ATTRIBUTE_POSITION, positions);
    mesh->insert_attribute(Mesh::ATTRIBUTE_NORMAL, normals);
    mesh->insert_attribute(Mesh::ATTRIBUTE_UV_0, uvs);
    mesh->insert_indices(indices);

    return mesh;
}

std::unique_ptr<Mesh> MeshFactory::create_plane(
    float width,
    float depth,
    std::uint32_t subdivisions
) {
    auto mesh = std::make_unique<Mesh>(RenderPrimitive::Triangles);

    std::vector<std::array<float, 3>> positions;
    std::vector<std::array<float, 3>> normals;
    std::vector<std::array<float, 2>> uvs;
    std::vector<std::uint32_t> indices;

    float half_width = width * 0.5f;
    float half_depth = depth * 0.5f;
    float dx = width / subdivisions;
    float dz = depth / subdivisions;

    for (std::uint32_t z = 0; z <= subdivisions; ++z) {
        for (std::uint32_t x = 0; x <= subdivisions; ++x) {
            float px = -half_width + x * dx;
            float pz = -half_depth + z * dz;
            float u = static_cast<float>(x) / subdivisions;
            float v = static_cast<float>(z) / subdivisions;

            push_vertex(
                positions,
                normals,
                uvs,
                px,
                0.0f,
                pz,
                0.0f,
                1.0f,
                0.0f,
                u,
                v
            );
        }
    }

    for (std::uint32_t z = 0; z < subdivisions; ++z) {
        for (std::uint32_t x = 0; x < subdivisions; ++x) {
            std::uint32_t row1 = z * (subdivisions + 1);
            std::uint32_t row2 = (z + 1) * (subdivisions + 1);

            std::uint32_t tl = row1 + x;
            std::uint32_t tr = row1 + x + 1;
            std::uint32_t bl = row2 + x;
            std::uint32_t br = row2 + x + 1;

            indices.push_back(bl);
            indices.push_back(tr);
            indices.push_back(tl);

            indices.push_back(bl);
            indices.push_back(br);
            indices.push_back(tr);
        }
    }

    mesh->insert_attribute(Mesh::ATTRIBUTE_POSITION, positions);
    mesh->insert_attribute(Mesh::ATTRIBUTE_NORMAL, normals);
    mesh->insert_attribute(Mesh::ATTRIBUTE_UV_0, uvs);
    mesh->insert_indices(indices);

    return mesh;
}

std::unique_ptr<Mesh> MeshFactory::create_arrow(
    float length,
    float shaft_radius,
    float head_length,
    float head_radius,
    std::uint32_t segments
) {
    auto mesh = std::make_unique<Mesh>(RenderPrimitive::Triangles);
    std::vector<std::array<float, 3>> positions;
    std::vector<std::array<float, 3>> normals;
    std::vector<std::array<float, 2>> uvs;
    std::vector<std::uint32_t> indices;

    float shaft_length = length - head_length;
    if (shaft_length < 0)
        shaft_length = 0;

    std::uint32_t index_offset = 0;
    float angle_step = 2.0f * PI / segments;

    // 1. Shaft Base Cap (Disk at Z=0, facing +Z)
    // Vertices
    {
        // Center vertex
        push_vertex(
            positions,
            normals,
            uvs,
            0.0f,
            0.0f,
            0.0f,
            0.0f,
            0.0f,
            1.0f, // Normal +Z
            0.5f,
            0.5f
        );
        std::uint32_t center_idx = index_offset++;

        // Ring vertices
        for (std::uint32_t i = 0; i <= segments; ++i) {
            float angle = i * angle_step;
            float x = shaft_radius * std::cos(angle);
            float y = shaft_radius * std::sin(angle);
            float u = (x / shaft_radius + 1.0f) * 0.5f;
            float v = (y / shaft_radius + 1.0f) * 0.5f;

            push_vertex(
                positions,
                normals,
                uvs,
                x,
                y,
                0.0f,
                0.0f,
                0.0f,
                1.0f,
                u,
                v
            );
        }
        index_offset += (segments + 1);

        // Indices (CCW looking from +Z)
        // Center, i+1 (Curr), i+2 (Next)
        for (std::uint32_t i = 0; i < segments; ++i) {
            indices.push_back(center_idx);
            indices.push_back(center_idx + i + 1);
            indices.push_back(center_idx + i + 2);
        }
    }

    // 2. Shaft Cylinder Body
    // From Z=0 to Z=-shaft_length
    std::uint32_t shaft_start_idx = index_offset;

    // Ring at Z=0
    for (std::uint32_t i = 0; i <= segments; ++i) {
        float angle = i * angle_step;
        float x = shaft_radius * std::cos(angle);
        float y = shaft_radius * std::sin(angle);
        float u = static_cast<float>(i) / segments;

        push_vertex(
            positions,
            normals,
            uvs,
            x,
            y,
            0.0f,
            std::cos(angle),
            std::sin(angle),
            0.0f,
            u,
            0.0f
        );
    }

    // Ring at Z=-shaft_length
    for (std::uint32_t i = 0; i <= segments; ++i) {
        float angle = i * angle_step;
        float x = shaft_radius * std::cos(angle);
        float y = shaft_radius * std::sin(angle);
        float u = static_cast<float>(i) / segments;

        push_vertex(
            positions,
            normals,
            uvs,
            x,
            y,
            -shaft_length,
            std::cos(angle),
            std::sin(angle),
            0.0f,
            u,
            1.0f
        );
    }
    index_offset += 2 * (segments + 1);

    // Indices for Shaft Body
    for (std::uint32_t i = 0; i < segments; ++i) {
        std::uint32_t row0 = shaft_start_idx;
        std::uint32_t row1 = shaft_start_idx + (segments + 1);

        std::uint32_t bl = row1 + i;
        std::uint32_t br = row1 + i + 1;
        std::uint32_t tl = row0 + i;
        std::uint32_t tr = row0 + i + 1;

        // Quad consisting of two triangles
        // tl, bl, tr
        indices.push_back(tl);
        indices.push_back(bl);
        indices.push_back(tr);

        // tr, bl, br
        indices.push_back(tr);
        indices.push_back(bl);
        indices.push_back(br);
    }

    // 3. Arrow Head Base (Cap at Z=-shaft_length, facing +Z)
    {
        // Center
        push_vertex(
            positions,
            normals,
            uvs,
            0.0f,
            0.0f,
            -shaft_length,
            0.0f,
            0.0f,
            1.0f,
            0.5f,
            0.5f
        );
        std::uint32_t center_idx = index_offset++;

        // Ring
        for (std::uint32_t i = 0; i <= segments; ++i) {
            float angle = i * angle_step;
            float x = head_radius * std::cos(angle);
            float y = head_radius * std::sin(angle);
            float u = (x / head_radius + 1.0f) * 0.5f;
            float v = (y / head_radius + 1.0f) * 0.5f;

            push_vertex(
                positions,
                normals,
                uvs,
                x,
                y,
                -shaft_length,
                0.0f,
                0.0f,
                1.0f,
                u,
                v
            );
        }
        index_offset += (segments + 1);

        // Indices
        for (std::uint32_t i = 0; i < segments; ++i) {
            indices.push_back(center_idx);
            indices.push_back(center_idx + i + 1);
            indices.push_back(center_idx + i + 2);
        }
    }

    // 4. Arrow Head Cone
    // Base at Z=-shaft_length, Tip at Z=-length
    std::uint32_t cone_start_idx = index_offset;

    // Cone Base Ring
    for (std::uint32_t i = 0; i <= segments; ++i) {
        float angle = i * angle_step;
        float x = head_radius * std::cos(angle);
        float y = head_radius * std::sin(angle);
        float u = static_cast<float>(i) / segments;

        // Normal calculation
        // Surface vector along side: Tip - Base = (0,0,-len)-(x,y,-shaft) =
        // (-x,-y,-head_len) Orthogonal vector pointing out: (+Radial, -Z)
        // Components: Radial = head_length, Z = -head_radius (Wait, Z needs to
        // be negative to point forward-out?) Let's recheck: Normal points
        // Out-Forward. Forward is -Z. Out is +Radial. So Z component should be
        // negative? Previously I concluded (+L, 0, -R) -> (+Radial, -Z). Let's
        // trust that.

        float hyp =
            std::sqrt(head_length * head_length + head_radius * head_radius);
        float nr = head_length / hyp;
        float nz = -head_radius / hyp; // Forward component

        float nx = std::cos(angle) * nr;
        float ny = std::sin(angle) * nr;

        push_vertex(
            positions,
            normals,
            uvs,
            x,
            y,
            -shaft_length,
            nx,
            ny,
            nz,
            u,
            0.0f
        );
    }

    // Cone Tip (Z=-length)
    for (std::uint32_t i = 0; i <= segments; ++i) {
        float angle = i * angle_step;
        float u = static_cast<float>(i) / segments;

        float hyp =
            std::sqrt(head_length * head_length + head_radius * head_radius);
        float nr = head_length / hyp;
        float nz = -head_radius / hyp;

        float nx = std::cos(angle) * nr;
        float ny = std::sin(angle) * nr;

        push_vertex(
            positions,
            normals,
            uvs,
            0.0f,
            0.0f,
            -length,
            nx,
            ny,
            nz,
            u,
            1.0f
        );
    }
    index_offset += 2 * (segments + 1);

    // Indices for Cone
    for (std::uint32_t i = 0; i < segments; ++i) {
        std::uint32_t base_idx = cone_start_idx + i;
        std::uint32_t base_next_idx = cone_start_idx + i + 1;
        std::uint32_t tip_idx = cone_start_idx + (segments + 1) + i;

        // Triangle: Base, BaseNext, Tip
        // Winding: Base -> BaseNext (Right) -> Tip (Down).
        // Right x Down = I x -K = J (Out). Correct.
        indices.push_back(base_idx);
        indices.push_back(base_next_idx);
        indices.push_back(tip_idx);
    }

    mesh->insert_attribute(Mesh::ATTRIBUTE_POSITION, positions);
    mesh->insert_attribute(Mesh::ATTRIBUTE_NORMAL, normals);
    mesh->insert_attribute(Mesh::ATTRIBUTE_UV_0, uvs);
    mesh->insert_indices(indices);

    return mesh;
}

std::unique_ptr<Mesh> MeshFactory::create_quad(float width, float height) {
    auto mesh = std::make_unique<Mesh>(RenderPrimitive::Triangles);

    float hw = width * 0.5f;
    float hh = height * 0.5f;

    std::vector<std::array<float, 3>> positions = {
        {-hw, hh, 0.0f},  // Top Left
        {-hw, -hh, 0.0f}, // Bottom Left
        {hw, -hh, 0.0f},  // Bottom Right
        {hw, hh, 0.0f}    // Top Right
    };

    std::vector<std::array<float, 3>> normals =
        {{0, 0, 1}, {0, 0, 1}, {0, 0, 1}, {0, 0, 1}};

    std::vector<std::array<float, 2>> uvs = {{0, 1}, {0, 0}, {1, 0}, {1, 1}};

    std::vector<std::uint32_t> indices = {0, 1, 2, 2, 3, 0};

    mesh->insert_attribute(Mesh::ATTRIBUTE_POSITION, positions);
    mesh->insert_attribute(Mesh::ATTRIBUTE_NORMAL, normals);
    mesh->insert_attribute(Mesh::ATTRIBUTE_UV_0, uvs);
    mesh->insert_indices(indices);

    return mesh;
}

} // namespace fei
